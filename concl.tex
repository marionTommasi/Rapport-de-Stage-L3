\section*{Discussion}
\addcontentsline{toc}{section}{Conclusion}

Durant ce stage, nous avons donc étudié une façon d'améliorer la compression et l'indexation des reads grâce à la \kbwt. Pour cela, nous avons trié la \kbwt\ sur ses $k$-contextes et stocké la fonction LF(). Nous avons également construit un algorithme pour améliorer la recherche de positions pour des motifs courts. Nous avons ensuite testé nos solutions sur des jeux de données représentatifs de reads sans erreurs.

Lors de ce stage, nous avons également examiné une autre approche pour réduire l'espace pris par la \kbwt et LF() : supprimer de la \kbwt\ les $k$-contextes contenant le symbole de fin de read \$, ceux-ci étant petits et ne représentant pas des motifs intéressants. Leur suppression aurait amélioré grandement le taux de compression, mais nous nous sommes rendus compte qu'ils étaient indispensables au fonctionnement de la structure, et cette piste n'a pas aboutie.

Pour continuer les recherches effectuées, il serait intéressant de calculer le gain de temps de construction entre la \bwt\ et la \kbwt\ triée, ainsi que les temps de recherche de motifs et de positions dans le texte avec l'algorithme présenté dans ce rapport. Il serait également intéressant de tester ces méthodes sur des jeux de données avec erreurs.

Pour finir, ces résultats nous permettent d'envisager des améliorations intéressantes. La fonction LF() que nous avons choisi de conserver est celle de la \kbwt\ non triée, mais il serait possible de calculer celle de la \kbwt\ triée. Il serait donc intéressant de calculer la compression de cette fonction, qui pourrait nous permettre de ne pas avoir à stocker les différences entre la \kbwt\ classique et celle triée. Une autre amélioration possible concerne la recherche de motifs plus grands que $k$. L'algorithme présenté à la fin de ce rapport pourrait en effet être adapté pour vérifier l'appartenance à un motif en plus de calculer la position dans le texte. En effet, comme expliqué dans la section sur la \kbwt, pour rechercher un motif plus grand que $k$ dans la \kbwt, il faut chercher son suffixe de taille $k$ puis tester tous les résultats en remontant la fonction LF() pour vérifier leur validité. Ce parcours de la fonction LF() pourrait donc être fait avec notre algorithme, en intégrant à cette recherche la recherche des positions, pour gagner en efficacité.

